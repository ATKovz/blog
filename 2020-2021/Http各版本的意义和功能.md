## HTTP 0.9

- 只有简单的 GET / 这类信息
- 没有请求头和其他功能

## HTTP 1.0

由于0.9的过于简陋，很多信息没法获取，同时性能也非常捉鸡，不太够用了，所以有了以下新增特性

- 添加了请求头/响应头，可以承载更多信息，允许有下面这些功能
- 响应头，可以设置 Cache/expire 这种性能优化属性
- 响应头，可以通过 Content-Type 来解析更多的格式，而不是单纯的文本
- 请求头，获取用户语言，平台（UA）等信息

- 状态码的引入，可以根据不同情况抛不同异常，还有处理不了的 500 等状态码，特殊情况处理有了很大的提升

## HTTP 1.1

由于 1.0 时代，每次 HTTP 请求都需要建立 TCP 链接 ，处理多个 HTTP 请求需要发起多次TCP流程，频繁的建立TCP链接显然不太行，为了解决这问题，有了以下特性

- 持久链接，一次 TCP 链接可以发起多次 HTTP 请求，单一域名最多可以有 6个TCP 持久链接
- HOST 字段，允许一台实体主机处理多个 host 名，也就是一个 IP 可以根据域名不同有多个虚拟主机
- Chunk transfer，把内容分块，有头尾标识，方便加载大小不明的动态内容
- Cookie 和安全机制引入

- 允许一次性发送多条 HTTP 请求，主要是用于解决持久链接的排队请求问题，但是不太成熟，基本等于没有

### 没解决的问题

1. TCP启动慢

HTTP1 下会多次建立 TCP， 而 TCP 的初始化到全速是比较慢的

2. 多个 TCP 链接 相互竞速
最高同时存在 6个 TCP 持久链接，他们之间的互相竞速抢带宽是不可控的，这导致可能部分关键资源会被其他的抢占带宽

3. 队头阻塞

一个请求慢了，后续的都会收到影响

## HTTP 2.0

由于

2.0 的解决方法基本就是多路复用，一个域名只用1次TCP链接

- 请求信息划分为多个 ** 带ID的二进制帧 ** 发送到服务端后由服务端合并，这个可以避免队头阻塞，
- 返回信息也是一样，由浏览器根据 ID 拼接合并后返回给请求
- 可以设置请求的优先级，避免了 TCP 相互竞速抢占资源的问题
- 请求头压缩，节省了大量空间，这个单纯提速优化

### 没解决的问题

1. HTTP2 还是 基于TCP的，所以数据包堵塞依旧没法避免，只是解决了多个 HTTP 请求间的阻塞，例如同时发出 id为1， 2， 3 的3个包，但是2号丢了，这种时候就会等待 2 再次获取后才能完成本次请求
2. 由于 2 只有单个 TCP 链接，所以每次丢包会丢掉一大串包 如果丢包率过高效率可能还不如 HTTP1.1 的 6路TCP
3. TCP 的握手 和 https的 TLS 必要的几次牵手还是会造成 至少 2RTT 的延迟

## HTTP 3.0

主要为了解决 HTTP TCP 和TLS 的 RTT 瓶颈