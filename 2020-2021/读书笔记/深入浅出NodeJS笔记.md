# 内存控制

1. 垃圾回收

垃圾回收见 笔记

2. 作用域

函数执行时会创建作用域，一级一级向上查找

## 手动释放

V8 通过是否有引用来判断变量是否需要释放，所以不用时要通过 解除引用或者删除来释放内存

** 不要通过 delete 来释放变量，这样可能会干扰V8优化 **

3. 闭包 (Closure)

通过闭包，我们可以访问到部分正常手段下无法访问到的作用域，即在作用域外访问作用域内的数据



闭包属于无法立即回收的内存，另外一种是全局变量，所以使用这两种时要小心

无法立即回收的会被移动到 老生代里， 当老生代超过 V8 的限制时， 就会导致 node 进程报错退出

4. Buffer

Buffer 占用的内存不经过 V8 分配， 会直接进入 RSS（resident set size），不受V8内存大小限制影响

5. Module

Node 里 module 会被加载到内存里，长时间占据老生代位置

所以设计模块时要及其小心，慎用可能会造成内存泄漏的全局变量，或者提供对应的清除方法

6. 队列

在某些高频率异步队列里，如果执行的速度赶不上入队速度，也可能导致内存泄漏

7. 大文件读写

大文件读写，可以使用 stream，来直接进行管道传输，流的方式可以避开V8内存限制


# Cookies

## 合理的使用cookies

1. 静态文件放到别的域名，避免 cookie 干扰到不必要的静态资源，增加了头部大小

2. cookies 只储存 一个 session id， 其他状态在服务器存储

session 可以用 redis 做持久化

### redis 优势

  - 可用空间大，不用和V8抢内存

  - 可持久化

### redis 劣势

  - 速度比内存慢

  - 多了一步查找流程（这步因为node服务器会和 缓存服务器持久链接，影响不是很大）

3. cookies 有安全性问题